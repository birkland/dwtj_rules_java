'''Defines the `java_binary` rule.
'''

load("//java:providers/JavaAgentInfo.bzl", "JavaAgentInfo")
load("//java:providers/JavaCompilationInfo.bzl", "JavaCompilationInfo")
load("//java:providers/JavaDependencyInfo.bzl", "JavaDependencyInfo")
load("//java:providers/JavaExecutionInfo.bzl", "JavaExecutionInfo")

load("//java:common/actions/compile_and_jar_java_sources.bzl", "compile_and_jar_java_target")
load("//java:common/actions/write_java_run_script.bzl", "write_java_run_script_from_ctx")
load("//java:common/extract/toolchain_info.bzl", "extract_java_runtime_toolchain_info", "extract_java_executable")
load(
    "//java:common/providers.bzl",
    "singleton_java_dependency_info",
    "make_legacy_java_info",
)

# NOTE(dwtj): This is very similar to `_java_test_impl()`.
def _java_binary_impl(ctx):
    java_compilation_info = compile_and_jar_java_target(ctx)
    java_dependency_info = singleton_java_dependency_info(
        java_compilation_info.class_files_output_jar,
    )
    java_execution_info, run_script, class_path_args_file, jvm_flags_args_file, run_time_jars = write_java_run_script_from_ctx(
        ctx,
        java_dependency_info,
        extract_java_runtime_toolchain_info(ctx),
    )

    runfiles = [
        extract_java_executable(ctx),
        run_script,
        class_path_args_file,
        jvm_flags_args_file,
    ]
    runfiles.extend(ctx.files.data)

    return [
        DefaultInfo(
            files = depset([java_compilation_info.class_files_output_jar]),
            executable = run_script,
            runfiles = ctx.runfiles(
                files = runfiles,
                transitive_files = run_time_jars,
            ),
        ),
        java_compilation_info,
        java_dependency_info,
        java_execution_info,
        make_legacy_java_info(java_compilation_info, ctx.attr.deps),
    ]

java_binary = rule(
    implementation = _java_binary_impl,
    attrs = {
        "srcs": attr.label_list(
            # TODO(dwtj): Consider supporting empty `srcs` list once `exports`
            #  is supported.
            allow_empty = False,
            doc = "A list of Java source files whose derived class files should be included in this binary (and any of its dependents).",
            allow_files = [".java"],
            default = [],
        ),
        "main_class": attr.string(
            mandatory = True,
        ),
        "deps": attr.label_list(
            providers = [
                JavaDependencyInfo,
                JavaInfo,
            ],
            default = [],
        ),
        "data": attr.label_list(
            default = list(),
            allow_files = True,
        ),
        "jvm_flags": attr.string_list(
            default = list(),
        ),
        "additional_jar_manifest_attributes": attr.string_list(
            doc = "A list of strings; each will be added as a line of the output JAR's manifest file. The JAR's `Main-Class` header is automatically set according to the target's `main_class` attribute.",
            default = [],
        ),
        # TODO(dwtj): A dict is used here in order to support Java agent
        #  options, but this causes two problems. First, it means that a single
        #  Java agent cannot be listed multiple times. Second, the order of
        #  agents is lost. These are problems because according to the
        #  [`java.lang.instrument` Javadoc][1], agents can be listed multiple
        #  times and their order dictates the sequence by which `premain()`
        #  functions are called. Thus, this design doesn't support all use cases
        #  provided by the `java` command line interface.
        #
        #  Unfortunately, I don't immediately see an alternative to this use of
        #  dict. At least these use cases are probably rare.
        #
        #  ---
        #
        #  1: https://docs.oracle.com/en/java/javase/14/docs/api/java.instrument/java/lang/instrument/package-summary.html
        "java_agents": attr.label_keyed_string_dict(
            doc = "A dict from `java_agent` targets to option strings. Each key is a `java_agent` target (i.e. a target which provides both `JavaAgentInfo` and `JavaDependencyInfo`) with which this target should be run; each value is an option string to be passed to that Java agent.",
            providers = [
                JavaAgentInfo,
                JavaDependencyInfo,
            ],
            default = dict(),
        ),
        "output_jar": attr.output(
            doc = "The name of the JAR file generated by this target. This JAR contains the class files generated by this target's Java compiler invocation.",
        ),
    },
    provides = [
        JavaCompilationInfo,
        JavaDependencyInfo,
        JavaExecutionInfo,
        JavaInfo,
    ],
    executable = True,
    toolchains = [
        "@dwtj_rules_java//java/toolchains/java_compiler_toolchain:toolchain_type",
        "@dwtj_rules_java//java/toolchains/java_runtime_toolchain:toolchain_type",
    ],
)
