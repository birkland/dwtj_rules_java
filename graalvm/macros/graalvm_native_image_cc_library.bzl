"""Defines the `graalvm_native_image_cc_library` macro, which is a helper macro
for declaring a `graalvm_native_image_library` rule and wraping its outputs
in appropriate rules from `@rules_cc`.
"""

load("@dwtj_rules_java//graalvm:rules/graalvm_native_image_library/defs.bzl", "graalvm_native_image_library")
load("@rules_cc//cc:defs.bzl", "cc_import", "cc_library")

_NAME_SUFFIXES = {
    "graalvm_native_image_library": "_graalvm_native_image_library",
    "library": ".so",
    "header": ".h",
    "dynamic_header": "_dynamic.h",
    "graal_isolate_header_cc_library": "_graal_isolate_header_cc_library",
    "graal_isolate_header_cc_library_dynamic": "_graal_isolate_header_cc_library_dynamic",
    "cc_import": "_cc_import",
    "cc_import_dynamic": "_cc_import_dynamic",
    "main_cc_library": "",
    "main_cc_library_dynamic": "_dynamic",
}

def _graal_isolate_header_strip_include_prefix():
    # TODO(dwtj): Check that this conditional is actually necessary.
    pkg = native.package_name()
    if pkg == "":
        return ""
    else:
        return "/" + pkg

# TODO(dwtj): In starlark, can we elide re-passing the `name` argument somehow?
#  Maybe a closure? Or maybe with a class and a class instance?
def _names(name, key):
    return name + _NAME_SUFFIXES[key]

def _main_library(name, main_library_visibility):
    # Wrap `graal_isolate.h` and strip the package include prefix. We strip the
    #  prefix so it can be found with via a `#include <graal_isolate.h>`
    #  directive. This is useful because the generated header file includes
    #  such a directive.
    # NOTE(dwtj): I expect that this will result in header file conflicts (about
    #  which Bazel is sure to complain) if two GraalVM native-image libraries
    #  created with this macro are linked together. However, in that case, a
    #  user can fall back on using the `graalvm_native_image_library` directly.
    # NOTE(dwtj): I believe that because `graal_isolate.h` doesn't use a prefix,
    #  it will name-clash with other `graal_isolate.h` files generated by other
    #  instantiations of this macro within this package, causing them to fail.
    #  similarly for the `graal_isolate_dynamic.h` file.
    # TODO(dwtj): Fix this problem to let the user instantiate the macro twice
    #  within the same bazel package.
    cc_library(
        name = _names(name, "graal_isolate_header_cc_library"),
        hdrs = ["graal_isolate.h"],
        strip_include_prefix = _graal_isolate_header_strip_include_prefix(),
    )

    # Import the shared library along with the generated header. This header
    # will be package-relative.
    cc_import(
        name = _names(name, "cc_import"),
        hdrs = [_names(name, "header")],
        shared_library = _names(name, "library"),
    )

    # Declare a `cc_library` which includes both the above library (to get the
    # `graal_isolate.h` file) and the above import (to get the `.h` and `.so`
    # files).
    cc_library(
        name = _names(name, "main_cc_library"),
        deps = [
            _names(name, "graal_isolate_header_cc_library"),
            _names(name, "cc_import"),
        ],
    )

def _main_library_dynamic(name, main_library_visibility):
    # NOTE(dwtj): See comments in `_main_library()`. This function is
    #  basically the same except w.r.t. the "dynamic" header file.
    cc_library(
        name = _names(name, "graal_isolate_header_cc_library_dynamic"),
        hdrs = ["graal_isolate_dynamic.h"],
        strip_include_prefix = _graal_isolate_header_strip_include_prefix(),
    )
    cc_import(
        name = _names(name, "cc_import_dynamic"),
        hdrs = [_names(name, "dynamic_header")],
        shared_library = _names(name, "library"),
    )
    cc_library(
        name = _names(name, "main_cc_library_dynamic"),
        deps = [
            _names(name, "graal_isolate_header_cc_library_dynamic"),
            _names(name, "cc_import_dynamic"),
        ],
        visibility = main_library_visibility,
    )

def graalvm_native_image_cc_library(
        name,
        main_class,
        deps,
        native_image_options = list(),
        visibility = ["//visibility:__pkg__"],
    ):
    '''Declares a `graalvm_native_image_library`; wraps it in two `cc_library`s.

    This macro creates various files and targets. However, the user should only
    need to use two of these targets: the `cc_library` named `<name>` and the
    `cc_library` named `<name>_dynamic`.

    Args:
      name: The name used for the main `cc_library` rule. This is also used as a
        prefix for various other intermediate/internal targets and files
        declared by this macro.
      main_class: Passed to the `graalvm_native_image_library` rule.
      deps: Passed to the `graalvm_native_image_library` rule.
      native_image_options: Passed to the `graalvm_native_image_library`
        rule. This no value is passed for this parameter, then this defaults
        to the empty list.
      visibility: The visibility applied to the main `cc_library` rules created
        by this macro. Other rules will have package default visibility. If no
        value is passed for this parameter, then `[//visibility:__pkg__]` is
        used.
    '''
    graalvm_native_image_library(
        name = _names(name, "graalvm_native_image_library"),
        main_class = main_class,
        deps = deps,
        native_image_options = native_image_options,
        library_output = _names(name, "library"),
        header_output = _names(name, "header"),
        dynamic_header_output = _names(name, "dynamic_header"),
        graal_isolate_header_output = "graal_isolate.h",
        graal_isolate_dynamic_header_output = "graal_isolate_dynamic.h",
    )
    _main_library(name, visibility)
    _main_library_dynamic(name, visibility)
